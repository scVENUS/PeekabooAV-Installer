diff --git /usr/share/rspamd/lualib/lua_scanners/common.lua /usr/share/rspamd/lualib/lua_scanners/common.lua
index a92d923d0..e9be8c3ab 100644
--- /usr/share/rspamd/lualib/lua_scanners/common.lua
+++ /usr/share/rspamd/lualib/lua_scanners/common.lua
@@ -62,7 +62,7 @@ local function match_patterns(default_sym, found, patterns, dyn_weight)
   end
 end
 
-local function yield_result(task, rule, vname, dyn_weight, is_fail, maybe_part)
+local function yield_result(task, rule, vname, dyn_weight, symbol_extra, maybe_part)
   local all_whitelisted = true
   local patterns
   local symbol
@@ -78,26 +78,31 @@ local function yield_result(task, rule, vname, dyn_weight, is_fail, maybe_part)
 
 
   -- This should be more generic
-  if not is_fail then
+  if not symbol_extra then
     patterns = rule.patterns
     symbol = rule.symbol
-    threat_info = rule.detection_category .. 'found'
+    threat_info = rule.detection_category .. ' found'
     if not dyn_weight then dyn_weight = 1.0 end
-  elseif is_fail == 'fail' then
+  elseif symbol_extra == 'fail' then
     patterns = rule.patterns_fail
     symbol = rule.symbol_fail
     threat_info = "FAILED with error"
     dyn_weight = 0.0
-  elseif is_fail == 'encrypted' then
+  elseif symbol_extra == 'encrypted' then
     patterns = rule.patterns
     symbol = rule.symbol_encrypted
     threat_info = "Scan has returned that input was encrypted"
     dyn_weight = 1.0
-  elseif is_fail == 'macro' then
+  elseif symbol_extra == 'macro' then
     patterns = rule.patterns
     symbol = rule.symbol_macro
     threat_info = "Scan has returned that input contains macros"
     dyn_weight = 1.0
+  elseif type(symbol_extra) == 'string' then
+    patterns = rule.patterns
+    symbol = symbol_extra
+    threat_info = string.format("special scan result set by %s: %s", rule.name, symbol_extra)
+    dyn_weight = 1.0
   end
 
 
@@ -121,8 +126,14 @@ local function yield_result(task, rule, vname, dyn_weight, is_fail, maybe_part)
     end
   end
 
-  if rule.action and is_fail ~= 'fail' and not all_whitelisted then
-    threat_table = table.concat(threat_table, '; ')
+  if rule.action
+    and (type(symbol_extra) == 'nil'
+        or symbol_extra == 'encrypted'
+        or symbol_extra == 'macro')
+    and not all_whitelisted
+    then
+
+      threat_table = table.concat(threat_table, '; ')
     if rule.action ~= 'reject' then
       flags = 'least'
     end
@@ -505,6 +516,7 @@ exports.match_patterns = match_patterns
 exports.condition_check_and_continue = need_check
 exports.save_cache = save_cache
 exports.create_regex_table = create_regex_table
+exports.gen_extension = gen_extension
 exports.check_parts_match = check_parts_match
 exports.check_metric_results = check_metric_results
 
diff --git /usr/share/rspamd/lualib/lua_scanners/init.lua /usr/share/rspamd/lualib/lua_scanners/init.lua
index 8c0f18caa..9ceab7663 100644
--- /usr/share/rspamd/lualib/lua_scanners/init.lua
+++ /usr/share/rspamd/lualib/lua_scanners/init.lua
@@ -31,6 +31,7 @@ local function require_scanner(name)
 end
 
 -- Antiviruses
+require_scanner('avast')
 require_scanner('clamav')
 require_scanner('fprot')
 require_scanner('kaspersky_av')
# had to change this to -38,17 and remove cloudmark line because that is not present in release
@@ -38,17 +39,17 @@ require_scanner('kaspersky_se')
 require_scanner('savapi')
 require_scanner('sophos')
 require_scanner('virustotal')
-require_scanner('avast')
 
 -- Other scanners
# +require_scanner('cloudmark')
 require_scanner('dcc')
-require_scanner('oletools')
 require_scanner('icap')
-require_scanner('vadesecure')
-require_scanner('spamassassin')
+require_scanner('oletools')
 require_scanner('p0f')
-require_scanner('razor')
+require_scanner('peekaboo')
 require_scanner('pyzor')
+require_scanner('razor')
+require_scanner('spamassassin')
+require_scanner('vadesecure')
 
 exports.add_scanner = function(name, t, conf_func, check_func)
   assert(type(conf_func) == 'function' and type(check_func) == 'function',
diff --git /usr/share/rspamd/lualib/lua_scanners/peekaboo.lua /usr/share/rspamd/lualib/lua_scanners/peekaboo.lua
new file mode 100644
index 000000000..ec81962af
--- /dev/null
+++ /usr/share/rspamd/lualib/lua_scanners/peekaboo.lua
@@ -0,0 +1,422 @@
+--[[
+Copyright (c) 2021, Vsevolod Stakhov <vsevolod@highsecure.ru>
+Copyright (c) 2021, Carsten Rosenberg <c.rosenberg@heinlein-support.de>
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+]]--
+
+--[[[
+-- @module peekaboo
+-- This module contains peekaboo access functions.
+-- Peekaboo is needed: https://github.com/scVENUS/PeekabooAV
+--]]
+
+local lua_util = require "lua_util"
+local tcp = require "rspamd_tcp"
+local upstream_list = require "rspamd_upstream_list"
+local rspamd_util = require "rspamd_util"
+local rspamd_http = require "rspamd_http"
+local rspamd_logger = require "rspamd_logger"
+local ucl = require "ucl"
+local common = require "lua_scanners/common"
+
+local N = 'peekaboo'
+
+local static_boundary = rspamd_util.random_hex(32)
+
+local function peekaboo_config(opts)
+
+  local peekaboo_conf = {
+    name = N,
+    scan_mime_parts = true,
+    scan_text_mime = false,
+    scan_image_mime = false,
+    url_check = '/v1/scan',
+    url_report = '/v1/report',
+    default_port = 8100,
+    use_https = false,
+    no_ssl_verify = true,
+    use_gzip = false,
+    timeout = 3.0,
+    log_clean = false,
+    retransmits = 2,
+    cache_expire = 7200, -- expire redis in 1d
+    min_size = 500,
+    message = '${SCANNER}: Peekaboo threat message found: "${VIRUS}"',
+    detection_category = "sandbox threat",
+    default_score = 1,
+    action = false,
+    dynamic_scan = false,
+    symbol = "PEEKABOO",
+    symbol_report = 'PEEKABOO_REPORT',
+    symbol_type = 'prefilter',
+    symbol_report_type = 'postfilter',
+    symbols = {
+      peekaboo_good = {
+        symbol = 'PEEKABOO_GOOD';
+        score = -1.0;
+        description = "The Peekaboo Whitelist entry";
+      },
+      peekaboo_in_process = {
+        symbol = 'PEEKABOO_IN_PROCESS';
+        score = 0;
+        description = "The Peekaboo analysis was not finished";
+      }
+    },
+    peekaboo_cache_name = N..'_jobs'
+  }
+
+  peekaboo_conf = lua_util.override_defaults(peekaboo_conf, opts)
+
+  if not peekaboo_conf.prefix then
+    peekaboo_conf.prefix = 'rs_' .. peekaboo_conf.name .. '_'
+  end
+
+  if not peekaboo_conf.log_prefix then
+    if peekaboo_conf.name:lower() == peekaboo_conf.type:lower() then
+      peekaboo_conf.log_prefix = peekaboo_conf.name
+    else
+      peekaboo_conf.log_prefix = peekaboo_conf.name .. ' (' .. peekaboo_conf.type .. ')'
+    end
+  end
+
+  if not peekaboo_conf.servers then
+    rspamd_logger.errx(rspamd_config, 'no servers defined')
+
+    return nil
+  end
+
+  peekaboo_conf.upstreams = upstream_list.create(rspamd_config,
+      peekaboo_conf.servers,
+      peekaboo_conf.default_port)
+
+  if peekaboo_conf.upstreams then
+    lua_util.add_debug_alias('external_services', peekaboo_conf.name)
+    return peekaboo_conf
+  end
+
+  rspamd_logger.errx(rspamd_config, 'cannot parse servers %s',
+      peekaboo_conf.servers)
+  return nil
+end
+
+local function peekaboo_url(rule, addr, maybe_url)
+  local url
+  local port = addr:get_port()
+
+  if port == 0 then
+    port = rule.default_port
+  end
+  if rule.use_https then
+    url = string.format('https://%s:%d%s', tostring(addr),
+        port, maybe_url)
+  else
+    url = string.format('http://%s:%d%s', tostring(addr),
+        port, maybe_url)
+  end
+
+  return url
+end
+
+
+local function peekaboo_check(task, content, digest, rule, maybe_part)
+  local function peekaboo_check_uncached ()
+    local upstream = rule.upstreams:get_upstream_round_robin()
+    local addr = upstream:get_addr()
+    local retransmits = rule.retransmits
+    local log_prefix = rule.log_prefix..'_check'
+
+    local request_url = peekaboo_url(rule, addr, rule.url_check)
+
+    local form_data = {}
+    local form_data_length = 0
+    local request_headers = {
+      ['Content-Type'] = string.format('multipart/form-data; boundary="%s"', static_boundary)
+    }
+
+    local content_disposition = maybe_part:get_header('Content-Disposition')
+    if content_disposition and string.sub(content_disposition,1,6) == 'inline' then
+      request_headers['X-Content-Disposition'] = 'inline'
+    end
+
+    local mime_type, mime_subtype, mime_attr = maybe_part:get_type_full()
+
+    local content_id = maybe_part:get_header('Content-ID')
+    local detected_extension = maybe_part:get_detected_ext()
+
+    table.insert(form_data, string.format('--%s\r\n', static_boundary))
+    if mime_attr['name'] then
+      table.insert(form_data,
+          string.format('Content-Disposition: form-data; name="file"; filename="%s"\r\n',
+              mime_attr['name']))
+    elseif content_id and detected_extension then
+      table.insert(form_data,
+          string.format('Content-Disposition: form-data; name="file"; filename="%s.%s"\r\n',
+              content_id, detected_extension))
+    elseif detected_extension then
+      table.insert(form_data,
+          string.format('Content-Disposition: form-data; name="file"; filename="file.%s"\r\n',
+              detected_extension))
+    else
+      table.insert(form_data,
+          string.format('Content-Disposition: form-data; name="file"\r\n'))
+    end
+
+    if mime_type then
+      table.insert(form_data,
+          string.format('Content-Type: %s/%s\r\n', mime_type, mime_subtype))
+    else
+      table.insert(form_data, 'Content-Type: text/plain\r\n')
+    end
+
+    lua_util.debugm(N, task, '%s: form-data BODY : %s', log_prefix, form_data)
+
+    table.insert(form_data, '\r\n')
+    table.insert(form_data, content)
+    table.insert(form_data, '\r\n')
+    table.insert(form_data, string.format('--%s--\r\n', static_boundary))
+
+
+    for _, f in ipairs(form_data) do
+      form_data_length = form_data_length + tonumber(#f)
+    end
+
+    table.insert(request_headers, string.format('Content-Length: %s\r\n', form_data_length))
+
+    lua_util.debugm(N, task, '%s: HTTP headers : %s', log_prefix, request_headers)
+
+    local function peekaboo_callback(err_message, code, body, headers)
+
+      local function peekaboo_requery(error)
+        -- set current upstream to fail because an error occurred
+        upstream:fail()
+
+        -- retry with another upstream until retransmits exceeds
+        if retransmits > 0 then
+
+          retransmits = retransmits - 1
+
+          -- Select a different upstream!
+          upstream = rule.upstreams:get_upstream_round_robin()
+          addr = upstream:get_addr()
+
+          lua_util.debugm(N, task, '%s: error: %s; retry IP: %s; retries left: %s',
+            log_prefix, error, addr, retransmits)
+
+          request_url = peekaboo_url(rule, addr, rule.url_check)
+
+          rspamd_http.request({
+            task=task,
+            url=request_url,
+            timeout=rule.timeout,
+            body=form_data,
+            callback=peekaboo_callback,
+            headers=request_headers,
+          })
+        else
+          rspamd_logger.errx(task, '%s: failed to scan, maximum retransmits '..
+              'exceed - err: %s', log_prefix, error)
+          common.yield_result(task, rule,
+              'failed to scan, maximum retransmits exceed - err: ' .. error,
+              0.0, 'fail', maybe_part)
+        end
+      end
+
+      if err_message or tonumber(code) >= 500 then
+
+        peekaboo_requery(code..' - '..err_message)
+
+      else
+        -- Parse the response
+        if upstream then upstream:ok() end
+
+        local peekaboo_jobs_table = task:cache_get(rule.peekaboo_cache_name) or {}
+
+        local ucl_parser = ucl.parser()
+        local ok, ucl_err = ucl_parser:parse_string(tostring(body))
+        if not ok then
+          rspamd_logger.errx(task, "%s: error parsing json response, retry: %s",
+            log_prefix, ucl_err)
+        end
+
+        local result = ucl_parser:get_object()
+
+        lua_util.debugm(N, task, '%s: Job ID: %s', log_prefix, result.job_id)
+        peekaboo_jobs_table[digest] = result.job_id
+        task:cache_set(rule.peekaboo_cache_name, peekaboo_jobs_table)
+
+      end
+    end
+
+    rspamd_http.request({
+      task=task,
+      url=request_url,
+      timeout=rule.timeout,
+      body=form_data,
+      callback=peekaboo_callback,
+      headers=request_headers,
+    })
+
+  end
+
+  if common.condition_check_and_continue(task, content, rule, digest,
+      peekaboo_check_uncached, maybe_part) then
+    return
+  else
+    peekaboo_check_uncached()
+  end
+
+end
+
+local function peekaboo_report(task, content, digest, rule, maybe_part)
+
+  local upstream = rule.upstreams:get_upstream_round_robin()
+  local addr = upstream:get_addr()
+  local retransmits = rule.retransmits
+  local log_prefix = rule.log_prefix..'_report'
+
+  local request_url = peekaboo_url(rule, addr, rule.url_report)
+
+  local peekaboo_jobs_table = task:cache_get(rule.peekaboo_cache_name)
+
+  if not peekaboo_jobs_table then return end
+
+  local job_id = peekaboo_jobs_table[digest]
+
+  local filename = maybe_part:get_filename()
+  local extension = common.gen_extension(filename)
+
+  local function peekaboo_callback(err_message, code, body, headers)
+
+    local function peekaboo_requery(error)
+      -- set current upstream to fail because an error occurred
+      upstream:fail()
+
+      -- retry with another upstream until retransmits exceeds
+      if retransmits > 0 then
+
+        retransmits = retransmits - 1
+
+        -- Select a different upstream!
+        upstream = rule.upstreams:get_upstream_round_robin()
+        addr = upstream:get_addr()
+
+        request_url = peekaboo_url(rule, addr, rule.url_report)
+
+        lua_util.debugm(N, task, '%s error: %s; retry IP: %s; retries left: %s',
+          log_prefix, error, addr, retransmits)
+
+        rspamd_http.request({
+          task=task,
+          url=request_url..'/'..job_id,
+          callback=peekaboo_callback,
+          timeout = rule.timeout,
+          mime_type='text/plain',
+        })
+      else
+        rspamd_logger.errx(task, '%s: failed to scan, maximum retransmits '..
+            'exceed - err: %s', log_prefix, error)
+        common.yield_result(task, rule,
+            'failed to scan, maximum retransmits exceed - err: ' .. error,
+            0.0, 'fail', maybe_part)
+      end
+    end
+
+    if err_message or tonumber(code) >= 500 then
+
+      peekaboo_requery(code..' - '..err_message)
+
+    elseif tonumber(code) == 404 then
+
+      lua_util.debugm(N, task, '%s: got 404 - not finished for job: %s',
+        log_prefix, job_id)
+      common.yield_result(task, rule, string.format('job_id: %s', job_id),
+        0.0, rule.symbols.peekaboo_in_process.symbol, maybe_part)
+    else
+      -- Parse the response
+      if upstream then upstream:ok() end
+      local ucl_parser = ucl.parser()
+      local ok, ucl_err = ucl_parser:parse_string(tostring(body))
+      if not ok then
+        rspamd_logger.errx(task, "%s %s: error parsing json response, retry: %s",
+          log_prefix, job_id, ucl_err)
+      end
+
+      local result = ucl_parser:get_object()
+
+      lua_util.debugm(N, task, '%s: job-id %s - JSON OBJECT - %s', log_prefix, job_id, result)
+
+      -- {[result] = bad, [reason] = Der Ausdruck (3) klassifizierte die Datei als Result.bad}
+
+      if result.result and tostring(result.result) ~= '' then
+        if tostring(result.result) == 'bad' then
+          lua_util.debugm(N, task, '%s: job-id %s - found bad result - %s (%s)',
+            log_prefix, job_id, result.result, result.reason)
+          common.yield_result(task, rule, string.format("job-id %s: %s", job_id, result.reason),
+            1.0, nil, maybe_part)
+          common.save_cache(task, digest, rule, 
+            string.format("job-id %s: %s", job_id, result.reason), 1.0, maybe_part)
+        elseif tostring(result.result) == 'failed' or tostring(result.result) == 'unchecked' then
+          lua_util.debugm(N, task, '%s: job-id %s - found failed/unchecked result - %s (%s)', 
+            log_prefix, job_id, result.result, result.reason)
+          common.yield_result(task, rule, string.format("job-id %s: %s", job_id, result.reason),
+            1.0, 'fail', maybe_part)
+        elseif tostring(result.result) == 'good' then
+          lua_util.debugm(N, task, '%s: job-id %s - found good result - %s (%s)', 
+            log_prefix, job_id, result.result, result.reason)
+          common.yield_result(task, rule, string.format("job-id %s: %s", job_id, result.reason),
+            rule.symbols.peekaboo_good.score, rule.symbols.peekaboo_good.symbol, maybe_part)
+          -- Do not save negative report to cache for now
+          -- common.save_cache(task, digest, rule,
+          --   string.format("job-id %s: %s", job_id, result.reason), rule.symbols.peekaboo_good.score, maybe_part)
+        elseif tostring(result.result) == 'ignored' then
+          lua_util.debugm(N, task, '%s: job-id %s - found ignored result - %s (%s)', 
+            log_prefix, job_id, result.result, result.reason)
+          -- Do not save negative report to cache for now
+          -- common.save_cache(task, digest, rule, 'OK', 0.0, maybe_part)
+        elseif tostring(result.result) == 'unknown' then
+          lua_util.debugm(N, task, '%s: job-id %s - found unknown result - %s (%s)', 
+            log_prefix, job_id, result.result, result.reason)
+          -- Do not save negative report to cache for now
+          -- common.save_cache(task, digest, rule, 'OK', 0.0, maybe_part)
+        end
+      else
+        rspamd_logger.errx(task, "%s %s: REPORT no result found: %s (%s)",
+          log_prefix, job_id, result.result, type(result.result))
+      end
+    end
+  end
+
+  if job_id and tonumber(job_id) > 0 then
+      lua_util.debugm(N, task, '%s: Calling Job-ID : %s', log_prefix, job_id)
+      rspamd_http.request({
+        task=task,
+        url=request_url..'/'..job_id,
+        callback=peekaboo_callback,
+        timeout = rule.timeout,
+        mime_type='text/plain',
+      })
+  else
+    rspamd_logger.errx(task, "%s: JOB-ID error: %s (%s) - IDs: %s",
+      log_prefix, job_id, type(job_id), peekaboo_jobs_table)
+  end
+end
+
+return {
+  type = {N, 'attachment scanner', 'hash', 'scanner'},
+  description = 'Peekaboo Sandbox Threat Scanner',
+  configure = peekaboo_config,
+  check = peekaboo_check,
+  report = peekaboo_report,
+  name = N
+}
diff --git /usr/share/rspamd/plugins/antivirus.lua /usr/share/rspamd/plugins/antivirus.lua
index 2ad5dc029..d05a7b67d 100644
--- /usr/share/rspamd/plugins/antivirus.lua
+++ /usr/share/rspamd/plugins/antivirus.lua
@@ -78,7 +78,7 @@ local eicar_pattern = rspamd_util.decode_base32(
     [[akp6woykfbonrepmwbzyfpbmibpone3mj3pgwbffzj9e1nfjdkorisckwkohrnfe1nt41y3jwk1cirjki4w4nkieuni4ndfjcktnn1yjmb1wn]]
 )
 
-local function add_antivirus_rule(sym, opts)
+local function add_scanner_rule(sym, opts)
   if not opts.type then
     rspamd_logger.errx(rspamd_config, 'unknown type for AV rule %s', sym)
     return nil
@@ -125,20 +125,32 @@ local function add_antivirus_rule(sym, opts)
     return nil
   end
 
-  rule.patterns = common.create_regex_table(opts.patterns or {})
-  rule.patterns_fail = common.create_regex_table(opts.patterns_fail or {})
-
   lua_redis.register_prefix(rule.prefix .. '_*', N,
       string.format('Antivirus cache for rule "%s"',
           rule.type), {
         type = 'string',
       })
 
+  -- if any mime_part filter defined, do not scan all attachments
+  if opts.mime_parts_filter_regex ~= nil
+      or opts.mime_parts_filter_ext ~= nil then
+    rule.scan_all_mime_parts = false
+  else
+    rule.scan_all_mime_parts = true
+  end
+
+  rule.patterns = common.create_regex_table(opts.patterns or {})
+  rule.patterns_fail = common.create_regex_table(opts.patterns_fail or {})
+
+  rule.mime_parts_filter_regex = common.create_regex_table(opts.mime_parts_filter_regex or {})
+
+  rule.mime_parts_filter_ext = common.create_regex_table(opts.mime_parts_filter_ext or {})
+
   if opts.whitelist then
     rule.whitelist = rspamd_config:add_hash_map(opts.whitelist)
   end
 
-  return function(task)
+  local function scan_cb(task)
     if rule.scan_mime_parts then
 
       fun.each(function(p)
@@ -166,6 +178,32 @@ local function add_antivirus_rule(sym, opts)
       cfg.check(task, task:get_content(), task:get_digest(), rule)
     end
   end
+
+  local function report_cb(task)
+    if cfg.report and type(cfg.report) == 'function' then
+      if rule.scan_mime_parts then
+
+        fun.each(function(p)
+          local content = p:get_content()
+          local clen = #content
+          if content and clen > 0 then
+            cfg.report(task, content, p:get_digest(), rule, p)
+          end
+        end, common.check_parts_match(task, rule))
+
+      else
+        cfg.report(task, task:get_content(), task:get_digest(), rule)
+      end
+    else
+      return
+    end
+  end
+
+  rspamd_logger.infox(rspamd_config, 'registered antivirus rule: symbol %s; type %s',
+    rule.symbol, rule.type)
+
+  return scan_cb, report_cb, rule
+
 end
 
 -- Registration
@@ -177,15 +215,17 @@ if opts and type(opts) == 'table' then
     if type(m) == 'table' then
       if not m.type then m.type = k end
       if not m.name then m.name = k end
-      local cb = add_antivirus_rule(k, m)
+      local scan_cb, report_cb, nrule = add_scanner_rule(k, m)
 
-      if not cb then
+      if not scan_cb then
         rspamd_logger.errx(rspamd_config, 'cannot add rule: "' .. k .. '"')
       else
-        rspamd_logger.infox(rspamd_config, 'added antivirus engine %s -> %s', k, m.symbol)
+
+        m = nrule
+
         local t = {
           name = m.symbol,
-          callback = cb,
+          callback = scan_cb,
           score = 0.0,
           group = N
         }
@@ -193,12 +233,38 @@ if opts and type(opts) == 'table' then
         if m.symbol_type == 'postfilter' then
           t.type = 'postfilter'
           t.priority = 3
+        elseif m.symbol_type == 'prefilter' then
+          t.type = 'prefilter'
+          t.priority = 3
         else
           t.type = 'normal'
         end
 
         local id = rspamd_config:register_symbol(t)
 
+        if report_cb and m.symbol_report then
+          rspamd_logger.infox(rspamd_config, 'added antivirus report symbol %s -> %s', k, m.symbol_report)
+          local r = {
+            name = m.symbol_report,
+            callback = report_cb,
+            score = 0.0,
+            group = N
+          }
+
+          if m.symbol_report_type == 'postfilter' then
+            r.type = 'postfilter'
+            r.priority = 3
+          elseif m.symbol_report_type == 'prefilter' then
+            r.type = 'prefilter'
+            r.priority = 3
+          else
+            r.type = 'normal'
+          end
+
+          rspamd_config:register_symbol(r)
+
+        end
+
         rspamd_config:register_symbol({
           type = 'virtual',
           name = m['symbol_fail'],
diff --git /usr/share/rspamd/plugins/external_services.lua /usr/share/rspamd/plugins/external_services.lua
index 02068685b..f77c41bfe 100644
--- /usr/share/rspamd/plugins/external_services.lua
+++ /usr/share/rspamd/plugins/external_services.lua
@@ -16,6 +16,7 @@ limitations under the License.
 ]] --
 
 local rspamd_logger = require "rspamd_logger"
+local rspamd_util = require "rspamd_util"
 local lua_util = require "lua_util"
 local lua_redis = require "lua_redis"
 local fun = require "fun"
@@ -105,12 +106,19 @@ external_services {
     }
     # `whitelist` points to a map of IP addresses. Mail from these addresses is not scanned.
     whitelist = "/etc/rspamd/antivirus.wl";
+    # Replace content that exactly matches the following string to the EICAR pattern
+    # Useful for E2E testing when another party removes/blocks EICAR attachments
+    #eicar_fake_pattern = 'testpatterneicar';
   }
 }
 ]])
   return
 end
 
+-- Encode as base32 in the source to avoid crappy stuff
+local eicar_pattern = rspamd_util.decode_base32(
+    [[akp6woykfbonrepmwbzyfpbmibpone3mj3pgwbffzj9e1nfjdkorisckwkohrnfe1nt41y3jwk1cirjki4w4nkieuni4ndfjcktnn1yjmb1wn]]
+)
 
 local function add_scanner_rule(sym, opts)
   if not opts.type then
@@ -181,8 +189,22 @@ local function add_scanner_rule(sym, opts)
 
       fun.each(function(p)
         local content = p:get_content()
-        if content and #content > 0 then
-          cfg.check(task, content, p:get_digest(), rule)
+        local clen = #content
+        if content and clen > 0 then
+          if opts.eicar_fake_pattern then
+            if type(opts.eicar_fake_pattern) == 'string' then
+              -- Convert it to Rspamd text
+              local rspamd_text = require "rspamd_text"
+              opts.eicar_fake_pattern = rspamd_text.fromstring(opts.eicar_fake_pattern)
+            end
+
+            if clen == #opts.eicar_fake_pattern and content == opts.eicar_fake_pattern then
+              rspamd_logger.infox(task, 'found eicar fake replacement part in the part (filename="%s")',
+                p:get_filename())
+              content = eicar_pattern
+            end
+          end
+          cfg.check(task, content, p:get_digest(), rule, p)
         end
       end, common.check_parts_match(task, rule))
 
@@ -191,10 +213,31 @@ local function add_scanner_rule(sym, opts)
     end
   end
 
+  local function report_cb(task)
+    if cfg.report and type(cfg.report) == 'function' then
+      if rule.scan_mime_parts then
+
+        fun.each(function(p)
+          local content = p:get_content()
+          local clen = #content
+          if content and clen > 0 then
+            cfg.report(task, content, p:get_digest(), rule, p)
+          end
+        end, common.check_parts_match(task, rule))
+
+      else
+        cfg.report(task, task:get_content(), task:get_digest(), rule)
+      end
+    else
+      return
+    end
+  end
+
   rspamd_logger.infox(rspamd_config, 'registered external services rule: symbol %s; type %s',
-      rule.symbol, rule.type)
+    rule.symbol, rule.type)
+
+  return scan_cb, report_cb, rule
 
-  return scan_cb, rule
 end
 
 -- Registration
@@ -206,16 +249,17 @@ if opts and type(opts) == 'table' then
     if type(m) == 'table' and m.servers then
       if not m.type then m.type = k end
       if not m.name then m.name = k end
-      local cb, nrule = add_scanner_rule(k, m)
+      local scan_cb, report_cb, nrule = add_scanner_rule(k, m)
 
-      if not cb then
+      if not scan_cb then
         rspamd_logger.errx(rspamd_config, 'cannot add rule: "' .. k .. '"')
       else
+
         m = nrule
 
         local t = {
           name = m.symbol,
-          callback = cb,
+          callback = scan_cb,
           score = 0.0,
           group = N
         }
@@ -223,12 +267,38 @@ if opts and type(opts) == 'table' then
         if m.symbol_type == 'postfilter' then
           t.type = 'postfilter'
           t.priority = 3
+        elseif m.symbol_type == 'prefilter' then
+          t.type = 'prefilter'
+          t.priority = 3
         else
           t.type = 'normal'
         end
 
         local id = rspamd_config:register_symbol(t)
 
+        if report_cb and m.symbol_report then
+          rspamd_logger.infox(rspamd_config, 'added external services report symbol %s -> %s', k, m.symbol_report)
+          local r = {
+            name = m.symbol_report,
+            callback = report_cb,
+            score = 0.0,
+            group = N
+          }
+
+          if m.symbol_report_type == 'postfilter' then
+            r.type = 'postfilter'
+            r.priority = 3
+          elseif m.symbol_report_type == 'prefilter' then
+            r.type = 'prefilter'
+            r.priority = 3
+          else
+            r.type = 'normal'
+          end
+
+          rspamd_config:register_symbol(r)
+
+        end
+
         if m.symbol_fail then
           rspamd_config:register_symbol({
             type = 'virtual',
